# 计算机系统原理

想要理解计算机的工作原理，那就来学计算机系统原理鸭！

### 知识点和错题解析

1、假定“int buf[2]={10,50};”所定义的buf被分配在静态数据区，其首地址为0x8048930，bufp1为全局变量，也被分配在静态数据区。以下关于“bufp1 = &buf[1];”的重定位的描述中，错误的是（ D ）。
A.在可重定位目标文件的.rel.text节中，有一个与buf相关的重定位条目
B.可用一条mov指令实现该赋值语句，该mov指令中有两处需要重定位
C.在相应的重定位条目中，对bufp1和buf的引用均采用绝对地址方式
D.在可重定位目标文件的.rel.data节中，有一个与bufp1相关的重定位条目

解析： A、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，所以，对buf的引用出现在机器代码中，即.text节中，因而重定位条目在.rel.text节中。
B、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，其源操作数和目操作数都需要重定位。
C、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，其源操作数和目操作数都是绝对地址方式。
D、因为“bufp1 = &buf[1];”是一个赋值语句，而不是一个声明，因而不需要对.data节中的bufp1变量进行重定位，也即重定位条目不在.rel.data节中。



2、以下关于ELF可执行目标文件的程序头表（段头表）的叙述中，错误的是（ B ）。
A.描述了每个可装入段的起始虚拟地址、存储长度、存取方式和对齐方式
B.用于描述可执行文件中的节与主存中的存储段之间的映射关系
C…text节和.rodata节都包含在只读代码段，而.data节和.bss节都包含在读写数据段
D.通过段头表可获得可装入段或特殊段的类型、在文件中的偏移位置及长度

解析： C选项可装入段包括只读代码段和可读写数据段，其中只读代码段包括ELF头，程序头表（段头表），.init节，.fini节，.text节，.rodata节。可读写数据段包括.data节和.bss节。



3、假定“int buf[2]={10,50};"所定义的buf被分配在静态数据区，其首地址为0x8048930，bufp1为全局变量，被分配在buf随后的存储空间。以下关于“int *bufp=&buf[1];"的重定位的描述中，错误的是_B__
A.在可执行目标文件中，地址0x8048938开始的4个字节为34H、89H、04H、08H
B.在可重定位目标文件的.rel.data节中，有一个引用buf的重定位条目
C.bufp1的地址为0x8048938，重定位前的内容为04H、00H、00H、 00H
D.在相应的重定位条目中，对bufp1和buf的引用均采用绝对地址方式

解析： A、可执行文件已经进行了重定位，所以，bufp1所在的地址0x8048938处，应该是重定位后的值，显然应该是buf[1]的地址。重定位时通过初始值加上buf的值得到，即4+0x8048930=0x8048934，小端方式下，4个字节分别为34H、89H、04H、08H。
B、在重定位条目中只有对buf的引用，没有对bufp1的引用，这里bufp1是一个定义。
C、因为“int *bufp1 = &buf[1];”是一个声明，也即是对变量bufp1的数据类型的定义和初始化，因此这个需要重定位的初始化值将被存储在.date节中，因而重定位条目在.rel.data节中，并且是绑定buf的一个引用，即引用buf的一个重定位条目。
D、因为buf有2个数组元素，每个元素占4B，因此bufp1的地址为0x8048930+8=0x8048938，重定位时与引用绑定的符号是buf，即绑定的是&buf[0]，而真正赋给bufp1的是&buf[1]，引用的地址和绑定的地址相差4，所以重定位前的内容为十六进制数04 00 00 00。



4、假定“int buf[2]={10,50};”所定义的buf被分配在静态数据区，其首地址为0x8048930，bufp1为全局变量，也被分配在静态数据区。以下关于“bufp1 = &buf[1];”的重定位的描述中，错误的是（ D ）。
A.在可重定位目标文件的.rel.text节中，有一个与buf相关的重定位条目
B.可用一条mov指令实现该赋值语句，该mov指令中有两处需要重定位
C.在相应的重定位条目中，对bufp1和buf的引用均采用绝对地址方式
D.在可重定位目标文件的.rel.data节中，有一个与bufp1相关的重定位条目

解析： A、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，所以，对buf的引用出现在机器代码中，即.text节中，因而重定位条目在.rel.text节中。
B、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，其源操作数和目操作数都需要重定位。
C、赋值语句“ bufp1 = &buf[1];”用movl指令可以实现，其源操作数和目操作数都是绝对地址方式。
D、因为“bufp1 = &buf[1];”是一个赋值语句，而不是一个声明，因而不需要对.data节中的bufp1变量进行重定位，即重定位条目不在.rel.data节中。



5、假定int型数组a的首址在 ECX中，i在EDX中， 则“&a[i]-a 送EAX"所对应的汇编指令是( movl %edx, %eax ）



6、以下有关重定位功能的叙述中，错误的是（ A ）。
A.重定位的最后一步是将引用处的地址修改为与之关联（绑定）的定义处的首地址
B.重定位的最终目标是重新确定各模块合并后每个引用所指向的目标地址
C.重定位的第二步是确定每个段的起始地址，并确定段内每个定义处符号的地址
D.重定位的第一步应先将相同的节合并，且将具有相同存取属性的节合并成段

解析： A、重定位最后一步是对引用处的地址进行重定位，重定位的方式有多种，只有绝对地址方式才是将引用处的地址修改为与之关联（绑定）的定义处的首地址，而对于其他重定位方式，就不一定是这样，例如，对于PC相对地址方式，引用处填写的是一个相对地址。



7、以下有关重定位信息的叙述中，错误的是（ B ）。
A.重定位信息包含需重定位的位置、绑定的符号和重定位类型
B.重定位信息是由编译器在生成汇编指令时产生的
C.数据中的重定位信息在可重定位目标文件的.rel.data节中
D.指令中的重定位信息在可重定位目标文件的.rel.text节中

解析： B、重定位信息应该是在汇编阶段生成的，只有在汇编阶段生成机器指令时才知道需要进行重定位的位置，因为这些需重定位的位置在机器指令中，例如，CALL指令中的偏移地址等。



8、Linux的目标文件格式是____C____ .
A、COM
B、COFF
C、ELF
D、EXE



9、假设一个C 语言程序有两个源文件：main.c 和test.c，它们的内容如图4.23 所示。对于编译生成的可重定位目标文件 test.o，填写下表中各符号的情况，说明每个符号是否出现在test.o的符号表（.symtab 节）中，如果是的话，定义该符号的模块是main.o 还是test.o、该符号的类型是全局、外部还是本地符号、该符号出现在test.o 中的哪个节（.text、.data 或.bss）

![img](https://img-blog.csdnimg.cn/20210126132021371.png)

![图-2](https://img-blog.csdnimg.cn/20210126132217552.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZVTk5ZUWlhbjEyMw==,size_16,color_FFFFFF,t_70#pic_center)



10、假设一个C 语言程序有两个源文件：main.c 和swap.c，其中，main.c 的内容如图4-7a 所示，而swap.c的内容如下：

![图-3](https://img-blog.csdnimg.cn/20210126132234854.png)

对于编译生成的可重定位目标文件swap.o，填写下表中各符号的情况，说明每个符号是否出现在swap.o的符号表（.symtab 节）中，如果是的话，定义该符号的模块是main.o 还是swap.o、该符号的类型是全局、外部还是本地符号、该符号出现在swap.o 中的哪个节（.text、.data 或.bss）。

![图-4](https://img-blog.csdnimg.cn/20210126132344386.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZVTk5ZUWlhbjEyMw==,size_16,color_FFFFFF,t_70#pic_center)



11、假定在MIPS 典型的5 级流水线处理器中，各主要功能部件的操作时间如下：存储器——200ps; ALU 和加法器——150ps ；寄存器堆读口和写口——50ps 。请回答下列问题：
( I ) 若执行阶段EX 所用的ALU 操作时间缩短20% ，则能否加快流水线执行速度？如果能，能加快多少？如果不能，请给出理由。
( 2 ) 若ALU 操作时间延长20% ，对流水线的性能有何影响？
( 3 ) 若ALU 操作时间延长40% ，对流水线的性能又有何影响？

解析：
( I ) ALU操作时间缩短20％不能加快流水线指令速度。因为指令流水线的执行速度取决于最慢的功能部件所用时间，最慢的是存储器，只有缩短了存储器的操作时间，才可能加快流水线速度。
( 2 ) ALU操作时间延长20％时，其操作时间变为180ps, 比存储器所用时间200ps还小。因此，对流水线性能没有影响。
( 3 ) ALU操作时间延长40％时，其操作时间变为210ps, 比存储器所用时间200ps大，因此，在不考虑流水段寄存器延时的情况下，流水线的时钟周期从200ps变为210ps, 流水线执行速度降低了(210-200)/200=5%。



12、某计算机主存地址空间大小有8MB, 分成32768个主存块，按字节编址；cache 可存放8KB 数据（不包括有效位、标记等附加信息），采用直接映射方式，间cache 共有多少行？主存地址如何划分？要求说明每个字段的含义、位数和在主存地址中的位置。

解：
主存：8MB=223B=215块 * 28B/块
Cache：8KB = 213B=25行 * 28B/行
所以cache共32行。
主存地址划分：

![表-1](https://img-blog.csdnimg.cn/20210126133322855.jpg#pic_center)

主存地址高10位为标记，中间5位为cache行号，低8位为块内地址。

解析：
每个主存块大小为8MB/32768=256B, 故cache 共有8KB/256B=32行。直接映射方式下，cache行号（即行索引）有5位；由于每个主存块大小为256B, 按字节编址，故块内地址为8位；主存地址空间大小为8MB, 所以地址位数为23位，故主存地址中标记有23-5-8=10位。综上所述，主存地址共有以下三个字段：高10位为标记字段，中间5位为行索引，低8位为块内地址。



13、某计算机主存地址空间大小为1GB, 按字节编址。cache 可存放64KB 数据，主存块大小为128 字节，采用直接映射和直写(write-through) 方式。请回答下列问题：
( I ) 主存地址如何划分？要求说明每个字段的含义、位数和在主存地址中的位置。
(2) cache 的总容量为多少位？

解：
（1）主存：1GB=230B=223块 * 27B/块
Cache：64KB=216B=29行 * 27B/行
主存地址划分：

![表-2](https://img-blog.csdnimg.cn/20210126133812391.jpg#pic_center)

主存地址高14位为标记，中间9位为cache行号，低7位为块内地址。
（2）Cache总容量=行数*（有效位+标记位+块内地址位数）=29 *（1+14+27 * 8）=531928bits=531.9Kbits

解析：
（1）cache 共有64KB/128B=512行，直接映射方式下，cache 行号占9位；由于每个主存块大小为128B, 按字节编址，故块内地址为7位；主存地址空间大小为1GB, 所以主存地址位数为30位。主存地址中标记有30-9-7=14位。综上所述，主存地址共有以下三个字段：高14位为标记，中间9位为行索引，低7位为块内地址。
（2）因为直接映射不考虑替换算法，所以cache 行中没有用于替换的控制位；因为采用直写方式，所以，cache行中也没有修改位。每个cache行中包含1位有效位、14位标记位和128B的数据，因此，cache 总容量为512 x (1+14+128 x 8)bit=519.5Kbits



14、

![图-5](https://img-blog.csdnimg.cn/2021012613440633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZVTk5ZUWlhbjEyMw==,size_16,color_FFFFFF,t_70)

解析： （1）主存：256MB=228B=222块 * 26B/块
Cache：8行=23行
主存地址划分：

![表-3](https://img-blog.csdnimg.cn/20210126134523947.jpg#pic_center)


主存地址高19位为标记，中间3位为cache行号，低6位为块内地址。
Cache总容量=行数 （有效位+标记位+块内地址位数）=8（1+19+648）=4256bits
（2）数组元素a[0][31]对应的cache行号为[(320+431)/64]mod 8 = 6 。
数组元素a[1][1]对应的cache行号为[(320+4*(1*256+1))/64]mod 8 = 5 。
要向下取整。



15、以下关于IA-32中整数运算指令所支持的操作数的叙述中，错误的是（A）。
A.除乘法指令外，其他运算指令的源操作数和目的操作数的位数相等
B.对于加减运算指令，操作数不区分是无符号整 数还是带符号整数
C.对于乘除运算指令，操作数一定区分是无符号 整数还是带符号整数
D.参加运算的操作数可以是一个字节（8b）、一 个字（16b）或双字（32b）

解析： A选项对于除法运算而言就是错的。



16、以下不属于程序链接好处的是（D）
A、一个程序可以分成很多源程序文件
B、可构建公共函数库，如数学库，标准C库等
C、时间上，可分开编译，空间上，无需包含共享库所有代码
D、采用链接更便于用户访问网页

解析： D选项与链接无关。
